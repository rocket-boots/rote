const Inventory = require('./Inventory');
const { DIRS_8 } = require('./constants');

class Item {
	constructor(options = {}) {
		this.type = options.type || null;
		this.name = options.name || 'nothing';
		this.x = options.x || 0;
		this.y = options.y || 0;
		this.character = options.character || '^';
		this.surrounding = options.surrounding || [];
		this.color = options.color || '#05f';
		this.background = options.background || null;
		this.inventory = new Inventory({
			size: options.inventorySize || 0
		});
		this.isWeapon = Boolean(options.weapon);
		this.damage = parseInt(options.weapon, 10) || 0;
		this.isDefense = Boolean(options.defense);
		this.defense = parseInt(options.defense, 10) || 0;
		this.illumination = options.illumination || 0;
		this.portable = (typeof options.portable === 'boolean') ? options.portable : true;
		this.containedIn = null;
		this.actions = { ...options.on, ...options.actions }; // TODO: do we need the "on" alias?
		if (options.use) {
			this.actions.use = options.use;
		}
		this.states = options.states || {};
		this.teleport = null; // can this item move the character to another level, cell
	}

	hasAction(verb) {
		return Boolean(this.actions[verb]);
	}

	action(actionName, who) {
		const action = this.actions[actionName];
		let actionOutcome = {};
		if (typeof action === 'function') {
			actionOutcome = action(this, who);
		} else if (typeof action === 'object' && action !== null) {
			actionOutcome = this.runAction(action, who);
		} else {
			console.warn('No action', actionName, 'for item', this);
		}
		return actionOutcome;
	}

	runAction(action = {}, who) { // TODO: move to game/level?
		let message = '';
		if (!this.requirementMet(action, who)) {
			message = (action.missingMessage) ? action.missingMessage : `Some requirement is not met to use the ${this.name}`;
			return { message };
		}
		this.removeRequirements(action);
		message = message + ((action.message) ? action.message : '');
		const effects = action.effects;
		return { message, effects };
	}

	removeRequirements(action = {}) {
		if (!action.requires) { return; }
		action.requires.forEach((requirement) => {
			const typeKey = requirement.item;
			if (typeKey) {
				this.inventory.removeType(typeKey);
			}
		});
	}

	requirementMet(action = {}, who) {
		if (!action.requires) {
			return true;
		}
		let met = 0;
		action.requires.forEach((requirement) => {
			if (requirement.item && this.inventory.containsType(requirement.item)) {
				met += 1;
			}
		});
		return met === action.requires.length;
	}

	draw(display, lighting = {}, inView = false) {
		if (this.containedIn || !inView) { // Not visible if in a container
			return false;
		}
		display.draw(this.x, this.y, this.character, this.color, this.background);
		if (this.surrounding.length) {
			this.surrounding.forEach((char, i) => {
				let { x, y } = DIRS_8[i];
				display.draw(this.x + x, this.y + y, char, this.color, this.background);
			});
		}
		return true;
	}

	addItem(item) { // mutates the item if successful
		if (this.inventory.isFull()) {
			return false;
		}
		const isAdded = this.inventory.add(item);
		if (!isAdded) {
			return false;
		}
		item.containedIn = this;
		return true;
	}

	//---- Inventory

	getContents(n) {
		return this.inventory.get(n);
	}

	hasContents() {
		return this.inventory.hasContents();
	}

	contains(itemName) {
		return this.inventory.contains(itemName);
	}

	hasSpace() {
		return this.inventory.hasSpace();
	}

	addToInventory(item) {
		return this.inventory.add(item);
	}

	//---- Sets

	setTeleport(options = {}) {
		const { levelIndex, x, y, verb } = options;
		this.teleport = { levelIndex, x, y };
		this.actions[verb] = 'teleport';
	}
}

module.exports = Item;
