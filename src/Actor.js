const ROT = require('rot-js');
const Inventory = require('./Inventory');
const geometer = require('./geometer');
const random = require('./random');

class ActionVerbType {
	static get MOVE () {
		return 'move';
	}

	static get WAIT () {
		return 'wait';
	}
}

class FactionType {

	static get HUMAN () {
		return 'human';
	}

	static get MONSTER () {
		return 'monster';
	}

	static get NEUTRAL () {
		return 'neutral';
	}
}


class Actor {
	constructor(options = {}) {
		this.type = options.type;
		this.name = options.name || null;
		this.faction = options.faction || FactionType.MONSTER;
		this.isHero = Boolean(options.isHero);
		this.x = options.x || 0;
		this.y = options.y || 0;
		this.character = options.character || 'M';
		this.originalCharacter = this.character;
		this.color = options.color || '#df2';
		this.originalColor = this.color;
		this.bloodColor = '#611';
		// this.game = options.game || console.error('must tie actor to game');
		this.inventory = new Inventory({
			size: options.inventorySize || 10
		});
		this.passable = false;
		this.actionQueue = [];
		this.maxMovement = this.isHero ? 1.42 : 1;
		this.sightRange = (typeof options.sightRange === 'number') ? options.sightRange : 6;
		this.target = null;
		this.aggro = options.aggro || 0; // Level will set this to 100 for monsters
		// stats
		this.hp = (options.hp || typeof options.hp === 'number') ? parseInt(options.hp, 10) : 2;
		this.hpMax = this.hp;
		this.ap = options.ap || 0;	// Attack/Arms
		this.apMax = this.ap;
		this.bp = options.bp || 0;	// Balance
		this.bpMax = this.bp;
		this.ep = options.ep || 0;	// Endurance
		this.epMax = this.ep;
		this.fp = options.fp || 0;		// Focus
		this.fpMax = this.fp;
		this.wp = options.wp || 0;		// Will(power)
		this.wpMax = this.wp;
		this.mp = options.mp || 0;		// Mana
		this.mpMax = this.mp;
		// advancement
		this.xp = options.xp || 0;
		this.score = options.score || 0;
		// abilities
		this.maxAbilities = 9;
		this.abilities = {};
		this.abilityList = [];
		// temporary
		this.initiativeBoost = 0;

		// all actors can carry currency
		// everything is boiled down to copper pieces
		// 100 copper = 1 silver
		// 100 silver = 1 gold
		this.currency = options.currency || 0;
	}

	draw(display, lighting = {}, inView = false) {
		if (!inView) {
			return false;
		}
		// TODO: adjust colors based on lighting and inView
		display.draw(this.x, this.y, this.character, this.color);
		return true;
	}

	queueAction(verb, params = {}) {
		const actionParams = { ...params, verb };
		this.actionQueue.push(actionParams);
	}

	clearQueue() {
		this.actionQueue.length = 0;
	}

	planAction(level, hero) {
		if (this.isHero) { return; }
		if (this.dead()) {
			this.clearQueue();
			return;
		}
		const distanceToHero = geometer.getDistance(this.x, this.y, hero.x, hero.y);
		const dangerouslyHurt = (this.hp <= 1);
		this.act = function () {
			console.log(`${this.name} acts`);
			// if (g.getActiveLevel() !== level) { return; }
		};
		if (this.aggro && distanceToHero <= this.getMaxSenseRange() && !hero.dead() && !dangerouslyHurt) {
			const map = level.getMap();
			this.clearQueue();
			this.setTarget(hero);
			this.setPathToTarget(map);
			if (this.atEndOfPath()) {
				this.queueAction('attack', { target: hero });
			} else if (this.actionQueue.length === 1) {
				this.clearQueue();
				this.queueAction('attack', { target: hero });
			}
		} else {
			if (this.atEndOfPath()) {
				this.setWanderPath(level);
			}
		}
		// console.log(`${this.name} plans`, this.actionQueue);
	}

	doAction() {
		if (this.dead()) { return { verb: 'rot' }; }
		const waitAction = { verb: ActionVerbType.WAIT };
		if (this.actionQueue.length === 0) { return waitAction; }
		let action = this.actionQueue.shift();
		const moveAlreadyThere = (action.verb === ActionVerbType.MOVE && action.x === this.x && action.y === this.y);
		const moveTooFar = (action.verb === ActionVerbType.MOVE && this.getDistanceToNextMove(action) > this.maxMovement);
		// console.log(this.name, this.x, this.y, action.verb, action.x, action.y, this.getDistanceToNextMove(), this.maxMovement, moveTooFar, 'q', this.actionQueue.length);
		if (moveAlreadyThere) {
			return this.doAction();
		}
		if (moveTooFar) {
			action = this.doAction();
		}
		if (!action) {
			return waitAction;
		}
		return action;
	}

	attack(who) {
		console.log(`${this.name} attacks`, who);
		// TODO
	}

	setWanderPath(level) {
		const map = level.getMap();
		const { x, y } = level.findRandomFreeCell();
		this.setPathTo(map, x, y);
	}

	atEndOfPath() {
		const nextAction = this.getNextAction();
		if (!nextAction) { return true; }
		return (nextAction.verb === ActionVerbType.MOVE) ? false : true;
	}

	wait() {
		this.healPools();
	}

	//---- Movement

	move(x, y) {
		this.x += parseInt(x, 10);
		this.y += parseInt(y, 10);
	}

	moveTo(x, y) {
		this.setCoordinates(x, y);
	}

	//---- Combat

	attackDamage(opponent) {
		return 1;
	}

	wound(n) {
		return this.heal(n * -1);
	}

	heal(n) {
		const originalHp = this.hp;
		this.hp += parseInt(n, 10);
		this.hp = Math.min(this.hp, this.hpMax);
		this.checkDeath();
		return this.hp - originalHp;
	}

	dead() {
		return (this.hp <= 0);
	}

	checkDeath() {
		if (this.dead()) {
			this.character = 'X';
			this.color = this.bloodColor;
			this.passable = true;
		}
	}

	//---- Healing

	healPools() {
		this.healPool(this.getRandomPoolKey());
	}

	healPool(poolKey, amount = 1) {
		const a = this.getAbilityReadiedAmounts();
		const max = this[poolKey + 'Max'];
		if (a[poolKey] + this[poolKey] + amount <= max) {
			this[poolKey] += amount;
		} else {
			if (this.isHero) {
				console.log('No space to heal', poolKey, this);
			}
		}
	}

	damagePool(poolKey, amount = 1) {
		this[poolKey] -= amount;
		this[poolKey] = Math.max(0, this[poolKey]);
	}

	//---- Abilities

	hasAbility(abilityKey) {
		return Boolean(this.abilities[abilityKey]);
	}

	addAbility(abilityKey, abilityData) {
		if (this.abilityList.length >= this.maxAbilities) {
			return false;
		}
		if (this.hasAbility(abilityKey)) {
			console.warn('Cannot add ability twice - would override');
			return;
		}
		// TODO: move to Activity class?
		const ability = JSON.parse(JSON.stringify(abilityData));
		this.abilities[abilityKey] = ability;
		ability.isReadied = false;
		ability.key = abilityKey;
		this.abilityList.push(abilityKey);
		return ability;
	}

	getAbilityByIndex(i) {
		const key = this.abilityList[i];
		return this.abilities[key];
	}

	getAbilityReadiedAmounts() {
		const a = { hp: 0, ap: 0, bp: 0, ep: 0, fp: 0, wp: 0 };
		this.abilityList.forEach((abilityKey) => {
			const ability = this.abilities[abilityKey];
			Actor.loopOverAbilityCosts(ability, (costKey, val) => {
				if (ability.isReadied) {
					a[costKey] += val;
				}
			});
		});
		return a;
	}

	canReadyAbility(ability) {
		if (ability.isReadied) { return false; }
		let canReady = true;
		Actor.loopOverAbilityCosts(ability, (costKey, val) => {
			const poolAmount = this[costKey];
			if (val > poolAmount) {
				canReady = false;
			}
		});
		return canReady;
	}

	readyAbilityByIndex(i) {
		const ability = this.getAbilityByIndex(i);
		if (!ability) { return false; }
		if (!this.canReadyAbility(ability)) { return false; }
		Actor.loopOverAbilityCosts(ability, (costKey, val) => {
			this[costKey] -= val;
		});
		ability.isReadied = true;
		return ability;
	}

	activateAbilities(eventName) {
		const triggeredAbilities = this.getTriggeredAbilities(eventName);
		let effects = [];
		triggeredAbilities.forEach((ability) => {
			ability.isReadied = false;
			effects = effects.concat(ability.effects);
		});
		return effects;
	}

	getTriggeredAbilities(eventName) {
		const triggeredAbilities = [];
		this.abilityList.forEach((abilityKey) => {
			const ability = this.abilities[abilityKey];
			if (ability.isReadied && ability.activateOn === eventName) {
				triggeredAbilities.push(ability);
			}
		});
		return triggeredAbilities;
	}

	static loopOverAbilityCosts(ability, fn) {
		const costs = Object.keys(ability.readyCost);
		costs.forEach((key) => {
			fn(key, parseInt(ability.readyCost[key], 10));
		});
	}

	static getAbilityEffectsString(ability) {
		let arr = [];
		ability.effects.forEach((effect) => {
			const words = (typeof effect === 'string') ? [effect] : Object.keys(effect);
			arr = arr.concat(words);
		});
		return arr.join(', ');
	}

	static getAbilityDescriptionHtml(ability) {
		let ready = 'Ready with';
		Actor.loopOverAbilityCosts(ability, (costKey, val) => {
			ready += ' ' + val + ' ' + costKey.toUpperCase();
		});
		const effects = Actor.getAbilityEffectsString(ability);
		return `<div class="ability-description">${ability.description}</div>
		<div class="ability-ready-with">${ready}</div>
		<div class="ability-activates-on">Activates on: ${ability.activateOn}</div>
		<div class="ability-effects">Causes: ${effects}</div>`;
	}

	//---- Experience

	gainRandomPoolMax() {
		const key = this.getRandomPoolKey() + 'Max';
		this[key] += 1;
	}

	gainRandomAbility(abilitiesData) {
		const abilityKeys = Object.keys(abilitiesData);
		let abilityKey = random.pickOne(abilityKeys);
		let attempts = 100;
		while (this.hasAbility(abilityKey) && attempts--) {
			abilityKey = random.pickOne(abilityKeys);
		}
		this.addAbility(abilityKey, abilitiesData[abilityKey]);
	}

	//---- Gets

	getRandomPoolKey() {
		return random.pickOne(['ap', 'bp', 'ep', 'wp']);
	}

	getMaxSenseRange() {
		return this.sightRange;
	}

	getNextAction() {
		return this.actionQueue[0];
	}

	getDistanceToNextMove(nextAction) {
		if (!nextAction) { nextAction = this.getNextAction(); }
		if (!nextAction) { return 0; }
		const { x, y } = nextAction;
		if (x !== undefined && y !== undefined) {
			return geometer.getDistance(x, y, this.x, this.y);
		}
		return null; // ?
	}

	getArmorDefense() {
		if (!this.isHero) {
			return 1; // TODO: change this so there is some kind of natural defense for monsters
		}
		let highestDefense = 0;
		this.inventory.loopOverContents((item) => {
			if (item.defense > highestDefense) {
				highestDefense = item.defense;
			}
		});
		return highestDefense;
	}

	getWeaponDamage() {
		if (!this.isHero) {
			return 1; // TODO: change this so there is some kind of natural damage for monsters
		}
		let highestDamage = 0;
		this.inventory.loopOverContents((item) => {
			if (item.damage > highestDamage) {
				highestDamage = item.damage;
			}
		});
		return highestDamage;
	}

	//---- Sets

	setCoordinates(x, y) {
		this.x = parseInt(x, 10);
		this.y = parseInt(y, 10);
	}

	setPathTo(map, x = 0, y = 0) {
		const passableCallback = function(x, y) {
			return map.getCellPassability(x, y);
		};
		const astar = new ROT.Path.AStar(x, y, passableCallback, { topology: 4 });
		const path = this.actionQueue;
		const pathCallback = function(x, y) {
			path.push({ x, y, verb: ActionVerbType.MOVE });
		};
		if (path[0] && path[0].x === this.x && path[0].y === this.y) {
			console.alert('removing first');
			path.shift();
		}
		astar.compute(this.x, this.y, pathCallback);
		return true;
	}

	setPathToTarget(map) {
		return this.setPathTo(map, this.target.x, this.target.y);
	}

	setTarget(target) {
		if (typeof target.x !== 'number' || typeof target.y !== 'number') {
			console.warn('Cannot set target to something without x,y');
			return;
		}
		this.target = target;
	}
}

module.exports = Actor;
